<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF=8">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html {
      font-family: monospace;
    }
  </style>
</head>

<body>
  <h1>title here</h1>

  <div id="sentiment">
    <!-- svg for sentiment line chart -->
    <svg id="linechart"></svg>
  </div>
  <div id="char-relations">
    <!-- svg for chord diagram -->
    <svg id="chord" height="850" width="850"></svg>
  </div>

  <script>
    const svg_linechart = d3.select("#linechart");
    const chord_chart_width = d3.select("#chord").attr("width");
    const chord_chart_height = d3.select("#chord").attr("height");
    const chord_diagram = d3.select("#chord").append("g");

    const requestData = async function () {
      // ----- load data -----
      const char_relations = await d3.json("character_relationships.json");
      console.log(char_relations);

      // ----- chord diagram -----
      // colors generated by http://vrl.cs.brown.edu/color
      const chord_colors = ['#399283', '#6ceac0', '#3337a6', '#a2e84f',
        '#20502e', '#9acfd8', '#19477d', '#b4a1e2'];
      let chord_nodes = char_relations.nodes;
      let chord_links = char_relations.edges;

      // make matrix
      let chord_matrix = [];
      let chord_connections = {};
      // matrix of zeroes
      for (let i = 0; i < chord_nodes.length; i++) {
        let row = [];
        for (let j = 0; j < chord_nodes.length; j++) {
          row.push(0);
        }
        chord_matrix.push(row);
        chord_connections[i] = [i];
      }
      // push values to matrix
      chord_links.forEach(d => {
        if (d.weight > 0) {
          chord_matrix[d.source_index][d.target_index] = d.weight; // times 1000?
          chord_matrix[d.target_index][d.source_index] = d.weight;

          chord_connections[d.source_index].push(d.target_index);
          chord_connections[d.target_index].push(d.source_index);
        }
      });
      console.log(chord_matrix);
      console.log(chord_connections);

      // make generators
      let chord_radius = (chord_chart_width / 2.0) - 120;
      let chord_gen = d3.chord()
        .padAngle(0.04)
        .sortSubgroups(d3.descending)
        .sortChords(d3.descending);
      let arc_gen = d3.arc()
        .innerRadius(chord_radius)
        .outerRadius(chord_radius + 20);
      let ribbon_gen = d3.ribbon().radius(chord_radius);
      let chords = chord_gen(chord_matrix);
      console.log(chords);

      // draw diagram
      chord_diagram.attr("transform", `translate(${chord_chart_width / 2.0},${chord_chart_height / 2.0})`);
      let chord_color_scale = d3.scaleOrdinal().range(chord_colors);
      // make rings
      let ring_container = chord_diagram.append("g");
      let rings = ring_container.selectAll("g.segment")
        .data(chords.groups)
        .join("g")
        .attr("class", "segment");
      rings.append("path")
        .attr("fill", d => chord_color_scale(chord_nodes[d.index]))
        .attr("stroke", d => chord_color_scale(chord_nodes[d.index]))
        .attr("d", arc_gen);
      // make ribbons
      let ribbon_container = chord_diagram.append("g");
      let ribbons = ribbon_container.selectAll("path.ribbon")
        .data(chords)
        .join("path")
        .attr("class", "ribbon")
        .attr("fill-opacity", 0.5)
        .attr("stroke", "none")
        .attr("fill", d => chord_color_scale(chord_nodes[d.source.index]))
        .attr("d", ribbon_gen);

      // add labels
      chords.groups.forEach(d => {
        let transform = '';

        let midpoint = (d.startAngle + d.endAngle) / 2;
        let rotation = midpoint * (180 / Math.PI) - 90;

        transform = transform + ` rotate(${rotation})`;
        transform = transform + ` translate(${chord_radius + 25}, 0)`;

        // flip the text if on the left half of the circle
        if (rotation > 90) {
          transform = transform + ` rotate(180)`;
          d.anchor = "end";
        }
        d.transform = transform;
      });

      rings.append("text")
        .attr("transform", d => d.transform)
        .text(d => chord_nodes[d.index].name)
        .attr("text-anchor", d => d.anchor);
    }
    requestData();
  </script>
</body>

</html>